/**
 * Generate ZK Proof Fixture for Foundry E2E Tests
 *
 * Two-step process:
 * 1. Use Noir.js + BB WASM to compute the commitment hash and execute the circuit
 * 2. Use the `bb` CLI (same version as Solidity verifier generator) to produce
 *    the proof with `--oracle_hash keccak` for EVM compatibility
 *
 * The fixture is saved as JSON for Foundry's vm.readFile() + vm.parseJsonBytes().
 *
 * IMPORTANT: The `bb` CLI version MUST match the one used to generate the
 * Solidity HonkVerifier (via `bb write_solidity_verifier`). Version mismatch
 * causes SumcheckFailed() errors even with valid proofs.
 *
 * Current versions:
 *   - bb CLI: ~/.bb/bb (3.0.0-nightly.20251104) — Solidity verifier generator
 *   - Noir:   1.0.0-beta.15
 *   - Circuit: packages/circuits/funding_proof
 *
 * Usage:
 *   npx tsx scripts/generate-proof-fixture.ts
 *
 * Output:
 *   contracts/sip-ethereum/test/fixtures/funding-proof.json
 */

import { Barretenberg } from '@aztec/bb.js'
import { writeFileSync, readFileSync, mkdirSync } from 'node:fs'
import { resolve, dirname } from 'node:path'
import { execSync } from 'node:child_process'

const FIXTURE_PATH = resolve(
  import.meta.dirname ?? __dirname,
  '../contracts/sip-ethereum/test/fixtures/funding-proof.json'
)

const BB_PATH = resolve(process.env.HOME ?? '~', '.bb/bb')
const CIRCUIT_DIR = resolve(
  import.meta.dirname ?? __dirname,
  '../packages/circuits/funding_proof'
)

function bigintToBuffer(n: bigint): Uint8Array {
  const hex = n.toString(16).padStart(64, '0')
  return new Uint8Array(Buffer.from(hex, 'hex'))
}

async function main() {
  console.log('=== SIP Funding Proof Fixture Generator ===\n')

  // Check bb CLI version
  const bbVersion = execSync(`${BB_PATH} --version`, { encoding: 'utf-8' }).trim()
  console.log(`bb CLI: ${BB_PATH} (${bbVersion})`)
  console.log(`Circuit: ${CIRCUIT_DIR}\n`)

  // 1. Compute commitment hash using BB primitives
  console.log('[1/4] Computing commitment hash...')
  const bb = await Barretenberg.new()

  const balance = 100n
  const minimumRequired = 50n
  const blinding = 12345n
  const assetId = 0xABCDn

  const commitResult = await bb.pedersenCommit({
    inputs: [bigintToBuffer(balance), bigintToBuffer(blinding)],
    hashIndex: 0,
  })

  const hashResult = await bb.pedersenHash({
    inputs: [commitResult.point.x, commitResult.point.y, bigintToBuffer(assetId)],
    hashIndex: 0,
  })

  const commitmentHash = Buffer.from(hashResult.hash).toString('hex')
  console.log(`  commitment_hash: 0x${commitmentHash}\n`)
  await bb.destroy()

  // 2. Write Prover.toml and execute circuit with nargo
  console.log('[2/4] Generating witness with nargo...')
  const proverToml = [
    '# Auto-generated by scripts/generate-proof-fixture.ts',
    `commitment_hash = "0x${commitmentHash}"`,
    `minimum_required = ${minimumRequired}`,
    `asset_id = "0x${assetId.toString(16).toUpperCase()}"`,
    `balance = ${balance}`,
    `blinding = "${blinding}"`,
  ].join('\n')

  writeFileSync(resolve(CIRCUIT_DIR, 'Prover.toml'), proverToml + '\n')
  execSync('nargo execute', { cwd: CIRCUIT_DIR, stdio: 'pipe' })
  console.log('  Witness generated\n')

  // 3. Generate proof with bb CLI (must use keccak oracle for EVM verifier)
  console.log('[3/4] Generating proof with bb CLI (--oracle_hash keccak)...')
  const proofDir = '/tmp/sip-proof-fixture'
  mkdirSync(proofDir, { recursive: true })

  const bytecode = resolve(CIRCUIT_DIR, 'target/funding_proof.json')
  const witness = resolve(CIRCUIT_DIR, 'target/funding_proof.gz')

  const bbCmd = [
    BB_PATH, 'prove',
    '-b', bytecode,
    '-w', witness,
    '-o', proofDir,
    '--oracle_hash', 'keccak',
    '--write_vk',
    '--verify',
  ].join(' ')

  execSync(bbCmd, { stdio: 'pipe' })
  console.log('  Proof generated and verified by bb CLI\n')

  // 4. Read proof and public inputs, save as JSON
  console.log('[4/4] Saving fixture...')
  const proofBytes = readFileSync(resolve(proofDir, 'proof'))
  const pubInputsBytes = readFileSync(resolve(proofDir, 'public_inputs'))

  const publicInputs: string[] = []
  for (let i = 0; i < pubInputsBytes.length; i += 32) {
    publicInputs.push('0x' + pubInputsBytes.slice(i, i + 32).toString('hex'))
  }

  const fixture = {
    _meta: {
      generator: 'scripts/generate-proof-fixture.ts',
      circuit: 'packages/circuits/funding_proof (Noir 1.0.0-beta.15)',
      backend: `UltraHonk (BB ${bbVersion}) — keccak oracle, ZK-enabled`,
      verifierTarget: 'evm',
      generatedAt: new Date().toISOString(),
    },
    params: {
      balance: balance.toString(),
      minimumRequired: minimumRequired.toString(),
      blinding: blinding.toString(),
      assetId: `0x${assetId.toString(16).toUpperCase()}`,
    },
    proof: '0x' + proofBytes.toString('hex'),
    proofBytes: proofBytes.length,
    publicInputs,
    publicInputsCount: publicInputs.length,
    proofType: 'funding',
  }

  mkdirSync(dirname(FIXTURE_PATH), { recursive: true })
  writeFileSync(FIXTURE_PATH, JSON.stringify(fixture, null, 2) + '\n')

  console.log(`  Path: ${FIXTURE_PATH}`)
  console.log(`  Size: ${(JSON.stringify(fixture).length / 1024).toFixed(1)} KB\n`)

  console.log('=== Summary ===')
  console.log(`  Proof size:     ${fixture.proofBytes} bytes`)
  console.log(`  Public inputs:  ${fixture.publicInputsCount}`)
  publicInputs.forEach((pi, i) => console.log(`    [${i}]: ${pi}`))
  console.log(`  BB version:     ${bbVersion}`)
  console.log()
  console.log('Done. Fixture ready for Foundry tests.')
}

main().catch((err) => {
  console.error('Fatal error:', err)
  process.exit(1)
})
