/**
 * PDF Export Utilities
 *
 * Lightweight PDF generation for audit reports without external dependencies.
 * Generates PDF 1.4 format documents with professional formatting.
 */

import type { AuditReport, PdfExportOptions } from './types'

/**
 * Generate a PDF document from an audit report
 *
 * Creates a professionally formatted PDF report with:
 * - Header with report metadata
 * - Summary statistics
 * - Optional transaction details table
 * - Footer with generation timestamp
 *
 * This implementation uses PDF 1.4 format and works in both Node.js and browsers.
 *
 * @param report - The audit report to export
 * @param options - PDF export options
 * @returns PDF document as Uint8Array
 *
 * @example
 * ```typescript
 * const report = await reporter.generateAuditReport({...})
 * const pdfBytes = generatePdfReport(report, {
 *   title: 'Q1 2025 Audit Report',
 *   organization: 'ACME Corp',
 * })
 *
 * // Save to file (Node.js)
 * fs.writeFileSync('audit-report.pdf', pdfBytes)
 *
 * // Download in browser
 * const blob = new Blob([pdfBytes], { type: 'application/pdf' })
 * const url = URL.createObjectURL(blob)
 * const a = document.createElement('a')
 * a.href = url
 * a.download = 'audit-report.pdf'
 * a.click()
 * ```
 */
export function generatePdfReport(
  report: AuditReport,
  options: PdfExportOptions = {}
): Uint8Array {
  const {
    title = 'SIP Protocol Audit Report',
    organization = '',
    includeTransactions = true,
    maxTransactions = 100,
  } = options

  // Build PDF content
  const content = buildPdfContent(report, {
    title,
    organization,
    includeTransactions,
    maxTransactions,
  })

  // Generate PDF binary
  return generatePdfBinary(content, title)
}

/**
 * Build PDF content structure
 */
function buildPdfContent(
  report: AuditReport,
  options: Required<PdfExportOptions>
): string {
  const lines: string[] = []

  // Header
  lines.push(options.title)
  if (options.organization && options.organization.trim() !== '') {
    lines.push(`Organization: ${options.organization}`)
  }
  lines.push(`Report ID: ${report.reportId}`)
  lines.push(
    `Generated: ${report.generatedAt.toISOString().replace('T', ' ').slice(0, 19)} UTC`
  )
  lines.push('')

  // Period
  lines.push('Report Period')
  lines.push(`  Start: ${formatDate(report.period.start)}`)
  lines.push(`  End:   ${formatDate(report.period.end)}`)
  lines.push('')

  // Summary Statistics
  lines.push('Summary Statistics')
  lines.push(`  Total Transactions: ${report.summary.transactionCount}`)
  lines.push(
    `  Total Volume: ${formatBigInt(report.summary.totalVolume)}`
  )
  lines.push(
    `  Unique Counterparties: ${report.summary.uniqueCounterparties}`
  )
  lines.push('')

  // Transaction Details
  if (options.includeTransactions && report.transactions.length > 0) {
    lines.push('Transaction Details')
    lines.push('')

    const txToShow = Math.min(
      report.transactions.length,
      options.maxTransactions
    )

    for (let i = 0; i < txToShow; i++) {
      const tx = report.transactions[i]
      lines.push(`Transaction ${i + 1}/${report.transactions.length}`)
      lines.push(`  ID: ${tx.id}`)
      lines.push(`  Sender: ${truncateAddress(tx.sender)}`)
      lines.push(`  Recipient: ${truncateAddress(tx.recipient)}`)
      lines.push(`  Amount: ${formatAmount(tx.amount)}`)
      lines.push(
        `  Timestamp: ${formatTimestamp(tx.timestamp)}`
      )

      if (tx.txHash) {
        lines.push(`  Tx Hash: ${truncateHash(tx.txHash)}`)
      }

      if (tx.metadata && Object.keys(tx.metadata).length > 0) {
        lines.push(`  Metadata: ${JSON.stringify(tx.metadata)}`)
      }

      lines.push('')
    }

    if (report.transactions.length > options.maxTransactions) {
      lines.push(
        `... and ${report.transactions.length - options.maxTransactions} more transactions`
      )
      lines.push('')
    }
  }

  // Footer
  lines.push('---')
  lines.push(
    'This report was generated by SIP Protocol compliance tools.'
  )
  lines.push('For verification, please contact your compliance officer.')

  return lines.join('\n')
}

/**
 * Generate PDF binary from text content
 *
 * Creates a minimal but valid PDF 1.4 document.
 * Uses Courier font for consistent monospace rendering.
 */
function generatePdfBinary(content: string, title: string): Uint8Array {
  // PDF object catalog
  const objects: string[] = []

  // Object 1: Catalog
  objects.push(
    '1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj'
  )

  // Object 2: Pages
  objects.push(
    '2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj'
  )

  // Object 3: Page
  objects.push(
    '3 0 obj\n<< /Type /Page /Parent 2 0 R /Resources 4 0 R /MediaBox [0 0 612 792] /Contents 5 0 R >>\nendobj'
  )

  // Object 4: Resources
  objects.push(
    '4 0 obj\n<< /Font << /F1 << /Type /Font /Subtype /Type1 /BaseFont /Courier >> >> >>\nendobj'
  )

  // Object 5: Content stream
  const contentStream = buildContentStream(content)
  objects.push(
    `5 0 obj\n<< /Length ${contentStream.length} >>\nstream\n${contentStream}\nendstream\nendobj`
  )

  // Object 6: Info
  const now = new Date()
  const pdfDate = formatPdfDate(now)
  objects.push(
    `6 0 obj\n<< /Title (${title}) /Author (SIP Protocol) /Creator (SIP SDK) /CreationDate (${pdfDate}) >>\nendobj`
  )

  // Build PDF structure
  const pdfParts: string[] = []

  // Header
  pdfParts.push('%PDF-1.4\n%\xE2\xE3\xCF\xD3\n')

  // Objects
  const xrefOffsets: number[] = [0] // Offset 0 for object 0 (null)
  let currentOffset = pdfParts.join('').length

  for (const obj of objects) {
    xrefOffsets.push(currentOffset)
    pdfParts.push(obj + '\n')
    currentOffset = pdfParts.join('').length
  }

  // Cross-reference table
  const xrefStart = currentOffset
  pdfParts.push('xref\n')
  pdfParts.push(`0 ${xrefOffsets.length}\n`)

  for (let i = 0; i < xrefOffsets.length; i++) {
    if (i === 0) {
      pdfParts.push('0000000000 65535 f \n')
    } else {
      const offset = String(xrefOffsets[i]).padStart(10, '0')
      pdfParts.push(`${offset} 00000 n \n`)
    }
  }

  // Trailer
  pdfParts.push('trailer\n')
  pdfParts.push(
    `<< /Size ${xrefOffsets.length} /Root 1 0 R /Info 6 0 R >>\n`
  )
  pdfParts.push('startxref\n')
  pdfParts.push(`${xrefStart}\n`)
  pdfParts.push('%%EOF')

  // Convert to Uint8Array
  const pdfString = pdfParts.join('')
  const encoder = new TextEncoder()
  return encoder.encode(pdfString)
}

/**
 * Build PDF content stream with text positioning
 */
function buildContentStream(text: string): string {
  const lines = text.split('\n')
  const commands: string[] = []

  // Begin text
  commands.push('BT')

  // Set font and size
  commands.push('/F1 10 Tf')

  // Set leading (line height)
  commands.push('12 TL')

  // Start position (left margin: 50, top margin: 50 from bottom)
  let y = 742 // Start from top (792 - 50)

  for (const line of lines) {
    // Move to position
    commands.push(`50 ${y} Td`)

    // Escape special characters in line
    const escaped = escapePdfString(line)

    // Show text
    commands.push(`(${escaped}) Tj`)

    // Move to next line
    y -= 12

    // Add new page if needed (simplified - just truncate for now)
    if (y < 50) {
      break
    }
  }

  // End text
  commands.push('ET')

  return commands.join('\n')
}

/**
 * Escape special characters for PDF strings
 */
function escapePdfString(str: string): string {
  return str
    .replace(/\\/g, '\\\\')
    .replace(/\(/g, '\\(')
    .replace(/\)/g, '\\)')
    .replace(/\r/g, '\\r')
    .replace(/\n/g, '\\n')
}

/**
 * Format date for PDF metadata (D:YYYYMMDDHHmmSS)
 */
function formatPdfDate(date: Date): string {
  const year = date.getUTCFullYear()
  const month = String(date.getUTCMonth() + 1).padStart(2, '0')
  const day = String(date.getUTCDate()).padStart(2, '0')
  const hour = String(date.getUTCHours()).padStart(2, '0')
  const minute = String(date.getUTCMinutes()).padStart(2, '0')
  const second = String(date.getUTCSeconds()).padStart(2, '0')

  return `D:${year}${month}${day}${hour}${minute}${second}Z`
}

/**
 * Format date for display (YYYY-MM-DD)
 */
function formatDate(date: Date): string {
  return date.toISOString().split('T')[0]
}

/**
 * Format bigint for display with thousands separator
 */
function formatBigInt(value: bigint): string {
  return value.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',')
}

/**
 * Format amount string with thousands separator
 */
function formatAmount(amount: string): string {
  try {
    const num = BigInt(amount)
    return formatBigInt(num)
  } catch {
    return amount
  }
}

/**
 * Format Unix timestamp to readable date
 */
function formatTimestamp(timestamp: number): string {
  const date = new Date(timestamp * 1000)
  return date.toISOString().replace('T', ' ').slice(0, 19) + ' UTC'
}

/**
 * Truncate address for display (0x1234...5678)
 */
function truncateAddress(address: string): string {
  if (address.length <= 12) {
    return address
  }
  return `${address.slice(0, 6)}...${address.slice(-4)}`
}

/**
 * Truncate hash for display
 */
function truncateHash(hash: string): string {
  if (hash.length <= 16) {
    return hash
  }
  return `${hash.slice(0, 8)}...${hash.slice(-8)}`
}
